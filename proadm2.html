<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - Non-Referred Student Data</title>
    <link rel="stylesheet" href="style.css">
    <script type="module" src="firebase-config.js"></script>
    <style>
        .terminal {
            background-color: #222;
            color: #00ff00;
            padding: 10px;
            margin-bottom: 15px;
            font-family: monospace;
            font-size: 14px;
            height: 250px;
            overflow-y: scroll;
        }

        .upload-section {
            margin-bottom: 20px;
            border: 1px solid #ccc;
            padding: 10px;
        }

        .upload-section textarea {
            width: 100%;
            height: 150px;
            margin-bottom: 10px;
        }

        .upload-progress-container {
            margin-bottom: 5px;
        }

        .upload-progress {
            width: 100%;
        }

        .validation-error {
            color: red;
            font-size: 12px;
        }

        .log-messages {
            margin-top: 15px;
            font-size: 12px;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <div class="admin-container">
        <h1>Non-Referred Student Data Management</h1>
        <button id="logout">Logout</button>

        <h3>Upload Non-Referred Student Data</h3>

        <div id="terminal" class="terminal"></div>

        <div class="upload-section">
            <textarea id="resultInput1" placeholder="Paste data here..."></textarea>
            <div class="upload-progress-container">
                <button class="uploadButton" data-input-id="resultInput1">Upload Batch 1</button>
                <progress id="progressBar1" class="upload-progress" value="0" max="100"></progress>
            </div>
            <p class="validation-error" id="validationError1"></p>
            <div id="logArea1" class="log-messages"></div>
        </div>

        <div class="upload-section">
            <textarea id="resultInput2" placeholder="Paste data here..."></textarea>
            <div class="upload-progress-container">
                <button class="uploadButton" data-input-id="resultInput2">Upload Batch 2</button>
                <progress id="progressBar2" class="upload-progress" value="0" max="100"></progress>
            </div>
            <p class="validation-error" id="validationError2"></p>
            <div id="logArea2" class="log-messages"></div>
        </div>

        <div class="upload-section">
            <textarea id="resultInput3" placeholder="Paste data here..."></textarea>
            <div class="upload-progress-container">
                <button class="uploadButton" data-input-id="resultInput3">Upload Batch 3</button>
                <progress id="progressBar3" class="upload-progress" value="0" max="100"></progress>
            </div>
            <p class="validation-error" id="validationError3"></p>
            <div id="logArea3" class="log-messages"></div>
        </div>

        <div class="upload-section">
            <textarea id="resultInput4" placeholder="Paste data here..."></textarea>
            <div class="upload-progress-container">
                <button class="uploadButton" data-input-id="resultInput4">Upload Batch 4</button>
                <progress id="progressBar4" class="upload-progress" value="0" max="100"></progress>
            </div>
            <p class="validation-error" id="validationError4"></p>
            <div id="logArea4" class="log-messages"></div>
        </div>

        <p id="overallStatus"></p>
    </div>

    <script type="module">
        import { auth, db } from "./firebase-config.js";
        import { ref, update } from "https://www.gstatic.com/firebasejs/11.5.0/firebase-database.js";
        import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.5.0/firebase-auth.js";

        // ‚úÖ Redirect if not logged in
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                window.location.href = "admin-login.html";
            }
        });

        // ‚úÖ Logout functionality
        document.getElementById("logout").addEventListener("click", () => {
            signOut(auth).then(() => {
                window.location.href = "admin-login.html";
            }).catch(error => {
                console.error("‚ùå Logout Error:", error);
            });
        });

        const terminal = document.getElementById("terminal");
        const overallStatus = document.getElementById("overallStatus");
        const uploadButtons = document.querySelectorAll(".uploadButton");
        const progressBars = {
            resultInput1: document.getElementById("progressBar1"),
            resultInput2: document.getElementById("progressBar2"),
            resultInput3: document.getElementById("progressBar3"),
            resultInput4: document.getElementById("progressBar4"),
        };
        const validationErrors = {
            resultInput1: document.getElementById("validationError1"),
            resultInput2: document.getElementById("validationError2"),
            resultInput3: document.getElementById("validationError3"),
            resultInput4: document.getElementById("validationError4"),
        };
        const logAreas = {
            resultInput1: document.getElementById("logArea1"),
            resultInput2: document.getElementById("logArea2"),
            resultInput3: document.getElementById("logArea3"),
            resultInput4: document.getElementById("logArea4"),
        };

        function logToTerminal(message) {
            terminal.innerHTML += `<span style="color: #00ff00;">> </span>${message}<br>`;
            terminal.scrollTop = terminal.scrollHeight;
        }

        function validateLine(line) {
            // More specific regex to capture roll and GPA, ignoring other parts
            const validPattern = /^(\d{6})\s*\(CGPA:.*?\)\s*\((.*?)\)\s*\[Referred:.*?\]$/;
            const match = line.match(validPattern);
            if (!match) {
                return "‚ùå Invalid Format (Expected: Roll (CGPA: ...) (sem1: gpa1, ...) [Referred: ...])";
            }

            const gpaPart = match[2];
            const gpaEntries = gpaPart.split(",");
            if (gpaEntries.length > 8) {
                return "‚ùå More than 8 semesters";
            }
            for (const entry of gpaEntries) {
                const [key, value] = entry.split(":").map(str => str.trim());
                if (key && value) {
                    if (key.toLowerCase().startsWith("st") && isNaN(value)) {
                        return `‚ùå Invalid GPA value: ${value} in ${key}`;
                    }
                } else if (entry.trim() !== "") {
                    return `‚ùå Invalid GPA entry format: ${entry}`;
                }
            }
            return null;
        }

        async function processAndUploadBatch(inputId, lines, startIndex, endIndex, batchUpdates, successfulUploads, failedUploads) {
            try {
                await update(ref(db), batchUpdates);
                const batchSize = Object.keys(batchUpdates).length;
                successfulUploads.count += batchSize;
                for (let i = startIndex; i < endIndex; i++) {
                    const line = lines[i];
                    const rollMatch = line.match(/^(\d{6})/);
                    if (rollMatch && !validateLine(line)) {
                        successfulUploads.lines.push(`Line ${i + 1}: ${rollMatch[1]}... - Success`);
                    }
                }
                return true;
            } catch (error) {
                console.error(`‚ùå Firebase Upload Error (${inputId}):`, error);
                failedUploads.count += Object.keys(batchUpdates).length;
                for (let i = startIndex; i < endIndex; i++) {
                    const line = lines[i];
                    const rollMatch = line.match(/^(\d{6})/);
                    if (rollMatch && !validateLine(line)) {
                        failedUploads.lines.push(`Line ${i + 1}: ${rollMatch[1]}... - Error: ${error.message}`);
                    }
                }
                return false;
            }
        }

        async function uploadResults(inputId) {
            const inputTextarea = document.getElementById(inputId);
            const progressBar = progressBars[inputId];
            const validationError = validationErrors[inputId];
            const logArea = logAreas[inputId];
            const uploadButton = Array.from(uploadButtons).find(btn => btn.dataset.inputId === inputId);

            const inputText = inputTextarea.value.trim();
            const lines = inputText.split("\n");
            const totalLines = lines.length;
            const batchSize = 1000;
            const successfulUploads = { count: 0, lines: [] };
            const failedUploads = { count: 0, lines: [] };
            const invalidLines = [];
            let processedCount = 0;

            progressBar.value = 0;
            progressBar.max = totalLines;
            validationError.innerText = "";
            logArea.innerHTML = "";
            uploadButton.disabled = true;
            logToTerminal(`üöÄ Starting upload for ${inputId} (${totalLines} lines)...`);

            // Validation
            for (let i = 0; i < totalLines; i++) {
                const error = validateLine(lines[i]);
                if (error) {
                    invalidLines.push(`Line ${i + 1}: ${lines[i]} - ${error}`);
                    logToTerminal(`‚ö†Ô∏è Validation Error (${inputId}): Line ${i + 1}: ${lines[i].substring(0, 60)}... - ${error}`);
                }
            }

            if (invalidLines.length > 0) {
                validationError.innerText = `‚ö†Ô∏è Found ${invalidLines.length} invalid lines. Check terminal.`;
                progressBar.value = 0;
                uploadButton.disabled = false;
                return;
            }

            for (let i = 0; i < totalLines; i += batchSize) {
                const batchLines = lines.slice(i, i + batchSize);
                const batchUpdates = {};
                const batchStartIndex = i;
                const batchEndIndex = Math.min(i + batchSize, totalLines);

                for (let j = 0; j < batchLines.length; j++) {
                    const line = batchLines[j];
                    // More specific regex to capture roll and GPA data
                    const match = line.match(/^(\d{6})\s*\(CGPA:.*?\)\s*\((.*?)\)\s*\[Referred:.*?\]$/);
                    if (match) {
                        const roll = match[1].trim();
                        const gpaData = {};
                        let semesterCount = 0;
                        const gpaEntries = match[2].split(",");
                        gpaEntries.forEach(entry => {
                            if (semesterCount < 8) {
                                const [key, value] = entry.split(":").map(str => str.trim());
                                if (key && value) {
                                    gpaData[key] = parseFloat(value);
                                    semesterCount++;
                                }
                            }
                        });
                        if (Object.keys(gpaData).length > 0) {
                            batchUpdates[`non_referred_students/${roll}`] = { gpa: gpaData };
                        } else {
                            const rollOnlyMatch = line.match(/^(\d{6})/);
                            if (rollOnlyMatch) {
                                successfulUploads.lines.push(`Line ${i + j + 1}: ${rollOnlyMatch[1]}... - No GPA data found`);
                            }
                        }
                    }
                }

                if (Object.keys(batchUpdates).length > 0) {
                    logToTerminal(`üì§ Uploading batch ${Math.ceil((i + batchSize) / batchSize)} for ${inputId} (${Object.keys(batchUpdates).length} records)...`);
                    const success = await processAndUploadBatch(inputId, lines, batchStartIndex, batchEndIndex, batchUpdates, successfulUploads, failedUploads);
                    if (success) {
                        logToTerminal(`‚úÖ Batch ${Math.ceil((i + batchSize) / batchSize)} uploaded successfully.`);
                    } else {
                        logToTerminal(`üî• Batch ${Math.ceil((i + batchSize) / batchSize)} failed.`);
                    }
                }

                processedCount += batchLines.length;
                progressBar.value = processedCount;
            }

            logArea.innerHTML = successfulUploads.lines.join("<br>") + (failedUploads.lines.length > 0 ? "<br><br>‚ùå Failed Records:<br>" + failedUploads.lines.join("<br>") : "");
            logToTerminal(`‚úÖ Finished upload for ${inputId}. Successful: ${successfulUploads.count}, Failed: ${failedUploads.count}, Invalid: ${invalidLines.length}.`);
            overallStatus.innerText = `‚úÖ Upload for ${inputId} finished. Successful: ${successfulUploads.count}, Failed: ${failedUploads.count}, Invalid: ${invalidLines.length}. Check individual log area for details.`;
            uploadButton.disabled = false;
            inputTextarea.value = ""; // Clear textarea after upload
        }

        uploadButtons.forEach(button => {
            button.addEventListener("click", async (event) => {
                const inputId = event.target.dataset.inputId;
                await uploadResults(inputId);
            });
        });
    </script>
</body>

</html>
